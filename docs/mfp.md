
# Multiplex Frame Protocol (MFP)

- [Типы подпротоколов](#типы-подпротоколов)
- [Схема протокола](#схема-протокола)
- [Служебный фрейм](#служебный-фрейм)
- [Бинарные данные](#бинарные-данные)
- [Примеры сообщений](#примеры-сообщений)

Бинарный протокол для WebSocket(и любого двунаправленного потокового транспорта), мультиплексирующий асинхронные сообщения, запросы-ответы и потоковую передачу файлов в одном соединении. Протокол использует компактный заголовок с битовыми флагами для определения структуры фрейма, что позволяет передавать строки, JSON и бинарные данные в одном фрейме с минимальными накладными расходами.

**Основная идея протокола:**

`MFP` решает проблему сложной и неунифицированной передачи разнородных данных в WebSocket-соединении. Вместо того чтобы изобретать сериализацию или заводить отдельные каналы для JSON, бинарных данных и управляющих команд — _всё передаётся в одном компактном сообщении, где каждый элемент имеет чёткую структуру и смысл_.

Протокол объединяет несколько типов данных в одном фрейме:

    [Основной блок данных][Карта приложений][file 1][file 2][file N][Контрольная сумма]

Протокол позволяет реализовать простую схему передачи/запроса сообщений и файлов:

```ts
const response = await request({ 
  endpoint: 'chat'
  data: 'Hello friend, here are my pictures.', 
  files: new Map([[0, {type: 'image/png', name: 'me.png', bin: ArrayBuffer}], ...])
})
```

На стороне получателя структура легко восстанавливается:

```ts
connection.on('chat', (data: JsonLike, files: Map) => {
  console.log(data) // 'Hello friend, here are my pictures.'
  const file = files.get(0) // name:'me.png'
})
```

**Возможности:**

* Запросы с любым типом разнородных данных в одном сообщении: `json(string) + binary(ArrayBuffer)`. Структура каждого фрейма определяется одним байтом, который содержит тип подпротокола и набор битовых флагов, описывающих наличие опциональных полей.
* Механизм подтверждений(опционально для каждого фрейма сообщения). Подтверждение полученного и декодированного фрейма возвращаются немедленно. Инициатор запроса может быть уверен в получении сообщения адресатом.
* Потоковая передача произвольных бинарных данных. Протокол позволяет анонсировать отправку одного или нескольких бинарных блоков, а затем передавать их содержимое по частям в отдельных легковесных сообщениях, привязанных к исходному анонсу.
* Проверка целостности данных с помощью контрольной суммы (опционально). Протокол поддерживает проверку целостности каждого сообщения с помощью контрольной суммы. Необходимость проверки указывается специальным флагом в заголовке сообщения, что позволяет включать её только для критически важных данных. Алгоритм контрольной суммы (например `CRC32`), используемый для расчетов, согласовывается сторонами один раз при установлении соединения или на уровне реализации.

**Типы операций:**

* Простое сообщение со смешанными данными в одном направлении.
* Запросы со смешанными данными аналогичные `POST` и ожиданием результата.
* Сообщение только с бинарными данными прикрепляемое к предварительно отправленному сообщению по `id`.
* Ответы на запросы со смешанными данными. 

## Типы подпротоколов

Под _подпротоколом_ следует понимать выбор декодера для конкретной схемы фрейма сообщения.
Максимальное количество `7`, что покрывает основные и, возможные, дополнительные варианты.

Типы подпротоколов (от 0 до 7):

* **0** - Резервный.
* **1 service** - Служебный фрейм. Подтверждения, ... и PING/PONG.
* **2 message** - Отправить данные без ожидания ответа.
* **3 request** - Отправить запрос с ожиданием ответа.
* **4 binary** - Бинарные данные с идентификатором предварительного сообщения и номером файла.
* **5 response** - Ответ на запрос `request` подобный `POST`.
* **6-7** - ... для расширений.

> Замечание: Время ожидания ответа на `request` согласовывается сторонами один раз при установлении соединения или на уровне реализации.

## Схема протокола

> Поля, идущие за обязательными первыми четырьмя сегментами, зависят от подпротокола и/или являются опциональными.

    [protocol: 3 бита][verification: 1 бит][flags: 4 бит][id: 4 байта][refId: 4 байта][size(payload): 4 байта][size(map): 4 байта][payload: N байт][map: N байт][bin: N байт][checksum: N байт]

| Поле                     | Размер        | Протокол |
| ------------------------ | ------------- | -------- |
| protocol                 | 3 бита        | Все      |
| checksum verification    | 1 бит         | Все      |
| flags                    | 4 бита        | Все      |
| id                       | 4 байта       | Все      |
| refId                    | 4 байта       | 1/4/5    |
| size(payload) (optional) | 4 байта       | 2/3/5    |
| size(map) (optional)     | 4 байта       | 2/3/5    |
| payload (optional)       | size(payload) | 2/3/5    |
| map (optional)           | size(map)     | 2/3/5    |
| key (optional)           | 4 байта       | 4        |
| bin (optional)           | N байт        | 2/3/5/4  |
| checksum (if 0b00010000) | N байт        | Все      |

Первые четыре сегмента обязательны и присутствуют в любом сообщении:

+ **protocol 3 бита** - Тип подпротокола, от `0` до `7`.
+ **verification 1 бит** - Флаг наличия `checksum` в конце сообщения.
+ **flags 4 бит** - Флаги полей сообщения.
+ **id 4 байта** - Уникальный идентификатор для каждой из сторон запросов в диапазоне от `1` до `0xFFFF_FFFF`.

> Замечание: Хотя флаг наличия `checksum` включен в протокол, реализация может игнорировать этот флаг и явно добавлять/верифицировать контрольную сумму.

Стандартные флаги **2(4 бит)** полей сообщения:

> Читай ниже [Служебный фрейм](#служебный-фрейм) и как [Бинарные данные](#бинарные-данные) интерпретируют флаги в `protocol:binary`.

* **0b0001** - Присутствуют данные.
* **0b0010** - Присутствует карта файлов вида `[number(key), number(size)][]` кратная 8(4+4) байтам. Может быть кратно 4 байтам `number(key)[]`, если это анонсированные файлы без самих файлов `0b0100`.
* **0b0100** - Присутствуют бинарные данные согласно размерам карты или, если карты нет, начало передачи потоковых данных.
* **0b1000** - Запрос требует немедленно выслать подтверждение(это не значит что его прочитал получатель).

Идентификаторы запросов `refId(4 байта)` устанавливаются только для конкретных подпротоколов:

* **protocol:service** - Идентификатор сообщения которое получено, декодировано и верифицировано(опционально).
* **protocol:binary** - Идентификатор предварительного сообщения к которому следует приложить файл.
* **protocol:response** - Идентификатор запроса для которого отправлен ответ.

Наличие полей и данных оценивается флагами и идут в строгом порядке:

+ **size(payload) 4 байта** - Размер данных если есть флаг `0b0001`.
+ **size(map) 4 байта** - Размер карты бинарных данных кратный 8(4+4) или 4(без файлов) байтам если есть флаг `0b0010`.
+ **payload N байт** - Данные если есть флаг `0b0001`.
+ **map N байт** - Карта файлов если есть флаг `0b0010`.
+ **key 4 байт** - Только для протокола `protocol:binary` - номер бинарного файла.
+ **bin N байт** - Бинарные данные если есть флаг `0b0100`.

## Служебный фрейм

> Замечание: Служебный фрейм `service` только подтверждает запросы и не имеет флага `0b1000`(смотри ниже).

Флаги служебного фрейма **protocol:service** оцениваются как константное значение последних трех бит `0b0111`:

* **0** - Не используется и служит заглушкой для типа.
* **1:ack** - Подтверждение получения сообщения и его верификации(опционально).
* **2:timeout** - Нами получен запрос(protocol:request), но приложение не подготовило ответ в отведенное время для возврата ответа protocol:response. _Почему может возникнуть такая ошибка? Слой реализации протокола может отличаться от приложения и быть настроен на собственный timeout независимо от приложения._
* **3:abort** - Обратная сторона требует прервать передачу сообщений с приложенными файлами(protocol:binary) или ответами(protocol:response) для указанного идентификатора.
* **4:unknown** - Нами получено сообщение (protocol:binary/response) ссылочный идентификатор которого (refId) не найден или уже обработан. Этот запрос не может быть обработан.
* **5-6** - Не используется(для расширений).
* **7:ping** - PING/. Для PONG используется `ack:1`.

Бит `0b1000` используется для идентификации `refId` в сообщении. Идентификаторы, генерируемые реализацией протокола, уникальны только для одной стороны соединения. Получив сервисное сообщение, требуется знать к кому относится поле `[refId: 4 байта]`:

* `0b1xxx` - Это сообщение связано с моим `refId`.
* `0b0xxx` - Это сообщение связано с твоим `refId`.

Таким образом, получатель сообщения сможет определить для какой операции можно применить запрос. Пример:

    // Отмени запрос, который ранее был инициирован мной, вот мой refId
    [1:service][0][0b1011][id:FFFFFFFF][refId:FFFFFFFF]
    // Я не дождался от приложения ответа на твой запрос, отмени его, вот твой refId
    [1:service][0][0b0010][id:FFFFFFFF][refId:FFFFFFFF]

## Бинарные данные 

Бинарные данные могут быть переданы как в сообщениях/запросах/ответах так и отдельно:

* Данные вместе с сообщением или запросом protocol:message/request/response. Сообщению установливаются флаги `0b0110` и прикладывается карта кратная 8(4+4) байт `[key:4 байта, size:4 байта][]`.
* Предварительное сообщение(protocol:message) с набором файлов (`0b0010`) кратным 4 байтам `key:4 байта[]`, после которой данные присоединяются из сообщений protocol:binary и формируется целостное сообщение. Номера файлов должны строго соответствовать ранее отправленной карте. Реализация протокола может иметь параметры, при которых одна ошибка проигнорирует все сообщение или вернет структуру без ошибочных файлов.
* Предварительное сообщение(protocol:message) без карты файлов (`0b0100`), после которой идет неограниченное число сообщений protocol:binary. Клиент получает поток сообщений с порядковыми номерами бинарных данных. Последнее сообщение идентифицируется отсутствием флагов в protocol:binary.

> **Замечание**: Протоколы запросов и ответов(protocol:request/response) не могут инициировать передачу файлов в нескольких сообщениях. **Причина**: Частичные сообщения, для сборки целостного сообщения, должны задерживаться реализацией протокола и хранить контекст незавершенной задачи, но запросы с ответами предполагают быструю реакцию и таймауты. Потоковые сообщения могут не иметь конца и неясно как обслужить ответ на такой запрос.

Формирование сообщения:

Клиент передает файлы в карте с уникальными номерами и размерами не выходящими за пределы `0xFFFF_FFFF`.
По ключам и размерам файлов формируется _плоская карта_ и добавляется к сообщению:

    [key1, size1]|[key2, size2]|...|[keyN, sizeN]
    // Для анонсированного сообщения без файлов
    key1|key2|...|keyN

После карты, в том же порядке, добавляются файлы:
    
    [key1, size1]|...|[keyN, sizeN]|file1|...|fileN

Если клиент желает разделить данные на несколько сообщений(protocol:message + protocol:binary) с заранее известной картой, и не желает использовать потоковую передачу, достаточно вложить в сообщение только карту `key:4 байта[]`. Протокол это оценит как первое сообщение и будет дожидаться всех приложенных файлов в сообщениях protocol:binary.

Флаги protocol:binary интерпретируются несколько иначе, но с то же семантикой как и предварительное сообщение protocol:message:

* **0b0001** - Установка этого бита говорит, что это не последнее сообщение. Если бит не установлен - это завершающее сообщение и реализация протокола может удалить сессию и более не ожидать файлов.
* **0b0010** - Файл отправлен вслед за предварительной картой с номером указанным в карте.
* **0b0100** - Была инициирована передача потока без предварительной карты. В сообщении порядковый номер файла или просто ключ.
* **0b0110** - Это сообщение не является приложенным файлом и здесь могут быть любые данные. Номер файла не устанавливается.
* **0b1000** - Как и везде - вернуть подтверждение в получении.

## Примеры сообщений

Отправить данные без запроса подтверждения:

    [2:message][0][0b0001][id:FFFFFFFF][size(payload):FFFFFFFF][payload:N]

Отправить данные с запросом на подтверждением(0b1000):

    [2:message][0][0b1001][id:FFFFFFFF][size(payload):FFFFFFFF][payload:N]

Такое тоже корректно 🤔:

    [2:message][1][0b0000][id:FFFFFFFF][checksum(CRC32):FFFFFFFF]

Отправить данные и приложенные файлы(0b0100 | 0b0010):

    // Полный запрос со всеми данными
    [2:message][1][0b1111][id:FFFFFFFF][size(payload):FFFFFFFF][size(map):FFFFFFFF][payload:N][map:N*8][bin:N][checksum(CRC32):FFFFFFFF]
    // Как и выше, но нет бита 0b0100, а значит файлы сейчас прибегут в protocol:binary
    [2:message][0][0b0011][id:FFFFFFFF][size(payload):FFFFFFFF][size(set):FFFFFFFF][payload:N][set:N*4]
    // Ничего нет, но есть флаг бинарных данных, которых тоже нет - означает начало
    // потоковой передачи в запросах protocol:binary
    [2:message][0][0b0100][id:FFFFFFFF]

Отправить запрос без подтверждения:

> Замечание: Запросы не могут инициировать потоковую передачу `0b0100` и должны быть в одном теле.

    // Запросы protocol:request аналогичны запросам message, но всегда ожидают ответ.
    // Несмотря на возможность установить флаг 0b1000, последний может быть
    // избыточен - запрос ожидает ответа и, скорее всего, установлен timeout
    [3:request][0][0b0001][id:FFFFFFFF][size(payload):FFFFFFFF][payload:N]

Отправить один непрерывный файл:

> Замечание: Подтверждение `0b1000`, при необходимости, должно быть указано для каждого файла, а не для всей группы предварительного сообщении.

    // Прикрепляем файл к сообщению refId и указываем по какой схеме предполагалось
    // отправить файл 0b0010 или потоковая передача 0b0100.
    [4:binary][0][0b1011][id:FFFFFFFF][refId:FFFFFFFF][key:FFFFFFFF][bin:N]
    // Потоковые данные не имеющие предварительной карты должны быть переданы с флагом 0b0100
    // Если это последнее сообщение, не устанавливаем флаг `0b0001`.
    [4:binary][1][0b0100][id:FFFFFFFF][refId:FFFFFFFF][key:FFFFFFFF][bin:N][checksum(CRC32):FFFFFFFF]
    // Последнее сообщение без файла. Порядковый номер и данные не устанавливаются.
    [4:binary][1][0b0000][id:FFFFFFFF][refId:FFFFFFFF][checksum(CRC32):FFFFFFFF]
    // Сообщение не имеющее отношения к файлам и завершающее. Порядковый номер не устанавливается.
    [4:binary][0][0b0110][id:FFFFFFFF][refId:FFFFFFFF][payload:N]

Вернуть ответ на запрос:

> Замечание: Ответы не могут инициировать потоковую передачу `0b0100` и должны быть возвращены в одном теле.

    // Ответ на запрос имеет ту же семантику как и protocol:request.
    [5:response][0][0b0001][id:FFFFFFFF][refId:FFFFFFFF][size(payload):FFFFFFFF][payload:N]
    // Ответы могут запросить подтверждение 0b1000
    [5:response][0][0b1111][id:FFFFFFFF][refId:FFFFFFFF][size(payload):FFFFFFFF][size(map):FFFFFFFF][payload:N][map:N*8][bin:N]

Подтверждение на любой тип сообщений кроме самого protocol:service:

> Фреймы подтверждений формируются реализацией протокола, а не клиентским приложением. Подтверждения доступны инициаторам запросов и сообщений, но не стороне для которой адресовано сообщение.

    // Сообщение с идентификатором refId успешно получено
    [1:service][0][0b0000+1:ack][id:FFFFFFFF][refId:FFFFFFFF]
    // Удали все задачи привязанные к refId - мы не сможем их обработать
    [1:service][0][0b1000+3:abort][id:FFFFFFFF][refId:FFFFFFFF]
